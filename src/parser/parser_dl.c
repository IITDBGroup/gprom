/*-----------------------------------------------------------------------------
 *
 * parser_dl.c
 *			  
 *		
 *		AUTHOR: lord_pretzel
 *
 *		
 *
 *-----------------------------------------------------------------------------
 */

#include "common.h"
#include "log/logger.h"
#include "mem_manager/mem_mgr.h"
#include "parser/parser.h"
#include "parser/parse_internal_dl.h"
#include "parser/parser_dl.h"
#include "dl_parser.tab.h"
#include "instrumentation/timing_instrumentation.h"

static Node *parseInternaldl (void);
static const char *languageHelp = "The user can specify a datalog program as a list of statements. "
        "A statement is either a rule, an answer predicate declaration, "
        "a regular path expression, or a provenance question.\n\n"
        "Rule\n"
        "----\n"
        "Description: declares a logical implication that is used to derive IDB facts.\n"
        "Syntax: A rule is of the following form:\n"
        "\t\tQ(X1, ..., Xn) :- BODY .\n"
        "\twhere Q is an IDB predicate and each Xi is an expression over constants and variables from the body\n"
        "\tand BODY is a list of RELATIONAL ATOM and COMPARISON ATOM elements\n"
        "\tA RELATIONAL_ATOM is of the form [NOT] R(Y1, ..., Yn) where R is an EDB or IDB predicate and each Yi is either a constant or a variable\n"
        "\tA COMPARISON_ATOM is of the form X op Y WHERE X and Y are constants or variables and op is one of <,>,=,!=\n"
        "Example: Q(X) :- R(X,Y), not R(Y,X).\n\n"
        "Answer Predicate Declaration\n"
        "----------------------------\n"
        "Description: determines which IDB predicate defined by a program will be returned as the result of the query.\n"
        "Syntax: The answer set declaration is of the form:\n"
        "\t\tANS : Q .\n"
        "\t where Q is an IDB predicate.\n"
        "Example: ANS : MyPred.\n\n"
        "Regular Path Expression\n"
        "-----------------------\n"
        "Description: declares a rules that matches regular paths over a ternary edge relation (fromNode, edgeLabel, toNode). "
        "Can be configured to return pairs of nodes that are staring and end points of paths matching the regular expression, "
        "all edges on a path.\n"
        "Syntax: RPQ(PATH_EXPR, RESULT_TYPE, E, R).\n"
        "\twhere PATH_EXPR is a regular expression over edge lables using operators\n"
        "\t\ta* = repeat a 0 or more times\n"
        "\t\ta+ = repeat a 1 or more times\n"
        "\t\ta.b = match a followed by b\n"
        "\t\ta? = match a 0 or 1 times\n"
        "\t\ta|b = match a or b\n"
        "\t RESULT_TYPE is one of {RESULT,PROV,SUBGRAPH}\n"
        "\t\tRESULT = return pairs of start and end nodes of paths matching the expression\n"
        "\t\tPROV = return for path matching the expression the end points paired with all edges that occur on the path\n"
        "\t\tSUBGRAPH = return all edges that occur on paths matching the expression\n"
        "\tE = an IDB predicate that stores the ternary edge relation\n"
        "\tR = the IDB predicate that will store the results of the RPQ expression\n"
        "Example: RPQ(\'a*.b\', RESULT, edge, result).\n\n"
        "Provenance Question\n"
        "-------------------\n"
        "Description: if a provenance question is specified then instead of evaluating the program, GProM will return the edge"
        " relation of a provenance graph explaining the existence respective absence of tuples matching the user question. The "
        "user can ask why and why-not questions asking for existence respective absence of query results.\n"
        "Syntax: A provenance question is of form\n"
        "\t\tWHY ( RELATIONAL_ATOM ) .\n"
        "\tor\n"
        "\t\tWHYNOT ( RELATIONAL_ATOM ) .\n"
        "Example: WHY(Q(1,2)).\n"
        ;

Node *
parseStreamdl (FILE *stream)
{
    dlin = stream;

    return parseInternaldl();
}

Node *
parseFromStringdl (char *input)
{
    INFO_LOG("parse SQL:\n%s", input);
    dlSetupStringInput(input);

    return parseInternaldl();
}

const char *
languageHelpDL (void)
{
    return languageHelp;
}

static Node *
parseInternaldl (void) //TODO make copyObject work first
{
    Node *result;
    START_TIMER("module - parser");

    NEW_AND_ACQUIRE_MEMCONTEXT("PARSER_CONTEXT");

    // parse
    int rc = dlparse();
    if (rc)
    {
        FATAL_LOG("parse error!");
        return NULL;
    }

    STOP_TIMER("module - parser");

    DEBUG_NODE_BEATIFY_LOG("datalog model generated by parser is:",
            dlParseResult);

    // create copy of parse result in parent context
    FREE_MEM_CONTEXT_AND_RETURN_COPY(Node,dlParseResult);
}

